\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage{listings}

\title {EGNER\\ Simulation d'un reseau de régulation de gène} 
\author {Sacha Schutz}
\date {\today}


	\begin{document}

	\maketitle

	\section{Introduction} % (fold)	
	Cette étude porte sur la simulation d'un réseaux de régulation de gène reprenant le modèle introduit par A. Wagner. Il s'agit de représenter l'Evolution d'un population possédant n gène ayant tous une activité promotrice sur ces même n gènes. L'expression de ce réseau génétique, est défini par un phénotype viable ou non , subissant une pression de sélection au cours du temps. Afin de réaliser ces simulations, le logiciel Egner sous license GPL, a été créer permettant de définir plusieurs paramètre de simuation et d'observer des phénomènes emergents au modèle.

	\begin{figure}[h]
	\label{figure1}
	\caption[test]{Représentation d'un réseau de 3 gène }
	\centering
	\includegraphics[scale=0.5]{shema1.png}
	\end{figure}

	\section{Materiels et Méthodes} 
	La modélisation de ce reseau génétique est illustré par la figure \ref{figure1}. L'activité represseur ou activateur des gènes est défini par une matrice de taille [NxN] ou N est le nombre de gène du reseau. Le phénotype, est quand à lui défini par un vecteur de taille [N]. \\
	La simulation a été écris entièrement en C++11 afin de béneficier de la programmation orienté objets et de profiter d'une vitesse de calcul convenable. Le framework Qt \footnote{Pronnoncé Cute  http://www.qt.io} a quand à lui permis la réalisation d'une interface graphique permettant d'interagir et de faire des observartions sur la population. L'ensemble du code source est disponible sur \emph{https://github.com/dridk/Egner}
	\subsection {Architecture}
	Le code source est divisé en 2 partie. Une partie appelé \textbf{Core} , contenant la logique pure et les classes de base nécessaires à la simulation. L'autre partie, appelé \textbf{Gui} contient les differents composants de l'interface graphique.
	\subsubsection {Core}
	Le réseau de gène a été modelisé sous forme d'une classe appelé \emph{GenotypeNetwork} contenant une matrice de dimension [NxN]. Cette classe possède des methodes d'écriture et de lecture des donnée matricielles ainsi que d'autre methodes pour générer des mutations aléatoire et des knockout de gène.
	Le Phenotype est représenté par la classe  \emph{Phenotype}, contenant un vecteur de dimension [N] et ses methodes d'acces. 
	La surcharge d'operateur, permise grâce au C++, a été appliqué a chacune de ces classes afin d'avoir des regles combinatoires. La code du listing \ref{code1} montre comment combiner 2 genotype avec eventuellement un crossing over.  Celui du listing \ref{code2}, comment effectuer le produit matricielle entre une genotype et un phenotype

	\begin{lstlisting}[language=C++, caption=Addition de genotype, label={code1}]

	GenotypeNetwork mother("0,0,2,4,1,7,5,0,4");
	GenotypeNetwork father("0,1,0,3,1,0,5,4,4");
	GenotypeNetwork child = mother + father
	//donnera par exemple : 0,0,2,3,1,0,5,8,4
	\end{lstlisting}

	\begin{lstlisting}[language=C++, caption=produit d'un genotype et d'un phenotype, label={code2}]

	GenotypeNetwork mother("0,0,2,4,1,7,5,0,4");
	Phenotype initial("1,1,1");
	initial = initial * mother;
	//donnera : -1,-1,1
	\end{lstlisting}

	Tous les indivdus défini par un \emph{GenotypeNetwork} sont contenu dans un classe \emph{Population}. Cette classe contient les méthodes d'ajouts et de suppression des individus. Mais ce sont les methodes \emph{init(size, mean, sd, geneCount)} et \emph{int next()} qui reste les plus importante. La première permet l'initiation d'une population aléatoire de taille \emph{size}, oû chaques individus contient un nombre de gène défini par \emph{geneCount}, dont les coefficients suivent une loi normal de moyenne \emph{mean} et d'ecart type \emph{sd}. Le calcul de cette loi normal a été permise par l'utilisation du C++11 et de sa nouvelle librarie standard . \\
	La deuxième permet de basculer de l'ancienne à la nouvelle population et retourne le nombre d'individu non viable qui a été crée. Ce basculement d'une popluation à l'autre a été optimisé par la methode swap(std::vector) de la std.
	. Voir l'example du listing \ref{code3} 
	\\
	\\

	\begin{lstlisting}[language=C++, caption=Generation d'une population et basculement vers la génération suivante, label={code3}]

	Population pop;
	pop.init(300, mean=0, sd=1, geneCount=3); 
	int deadNumber = pop.next();

	\end{lstlisting}

	\subsubsection {Gui}
	L'interface graphique a été réalisé grâce au Framework Qt. Disponible sous double license LGPL, Qt permet la création d'interface graphique de grande qualité et s'execute sous toutes les platformes windows, mac et linux. Les differents graphiques ont été réalisé avec la librairie QCustomPlot \footnote{www.qcustomplot.com} egalement sous license GPL. \\
	Chaques GenotypeNetwork a été representé visuellement sous forme d'une matrice (figure \ref{figure2}) ou chaques coefficient est coloré suivant un gradient rouge vert.Ces deux couleurs representant respectivement la valeur minimal et maximal des coefficient sur l'ensemble de la population.

	\begin{figure}[h]
	\label{figure2}
	\caption[test]{Representation graphique d'un GenotypeNetwork }
	\centering
	\includegraphics[scale=1]{genotypepixmap.png}
	\end{figure}


	\clearpage
	Le code source comprend 2 vues de la population courrante sur le panneau central et plusieurs outils sur le panneau de gauche pour manipuler la population. La figure \ref{figure3} résume toutes les actions possible du logiciel.
	\subsubsection {La Vue Grid}
	Cette vue affiche la population courante en listant l'ensemble des genotypeNetwork par leurs representations graphiques. C'est une vision idéal pour observer les differentes valeurs des coefficients dans leurs globalité. 
	\subsubsection { La vue Stat}
	Cette vue represente les frequences des coeffients pour chaques gènes. Ainsi, si la population est constitué d'indivdu avec 3 gènes, il y a yaura 9 coefficient, soit 9 histogramme. Cette representation est interessante, pour visualiser une population généré par une loi normal.
	\subsubsection {L'outil Initialisation}
	Permet de générer une population initial en specifiant les propriétés de la loi normal ainsi que le nombre de gène par individus.
	\subsubsection{ L'outil Run}
	Permet de lancer la simulation et possède les actions pour générer les graphique lineplot et histogram plot. LinePlot affiuche la courbe de viabilité global de la population pour chaques itération. tandis que Histogram Plot affiche la viabilité global depuis le dernier run. 
	\subsubsection{L'outil Knockout}
	Permet de desactiver des gènes sur la population courante . Pour chaques individus, les coefficients du gènes selectionné sont mis à zero. 
	\subsubsection{L'outil mutation}
	Permet quand à lui de générer des mutation aléatoire sur la population en cours. En fonction de la probabilité défini, un nombre d'individu subira une mutation de ses coefficients par une addiction ou soustraction de la valeur Step.

	


	\section {Résultat}
	Plusieurs experiences ont été réalisé avec le logiciel Egner. Ci dessous seront décris chaques expériences séparément avec leurs résultats .

	\subsection{Homogénisation de la population}
	\subsubsection{XP1 : Nécessité ou contingence ?}
	Lors de plusieurs essaie, a été remarqué, que sans aucune mutation, les populations convergent vers une homogénéisation des génotypes. C'est à dire qu'a partir d'une population initial variable, on observe au bout de plusieurs itération, une population de clone avec le même génotype. La question était de savoir si ce dernier clone était le résultat d'une finalité optimal depuis la population initial, ou le résultat d'une contingence. \\
	Une population initial aléatoire de 200 individus viable a été généré, puis sauvegarder dans un fichier. A partir de celui ci, plusieurs run de 1000 itération ont été réalisé puis comparé. Comme vous pouvez le voir sur la figure \ref{xp1}, les clones finaux sont différents et ne convergent pas à priori vers un même génotype. 

	\begin{figure}[h]
	\label{xp1}
	\caption[test]{Genotypes finaux à partir de la même population initial}
	\centering
	\includegraphics[scale=0.5]{xp1.png}
	\end{figure}
	A partir de la même population initial, et sans mutation, les clones finaux sont toujours différent. Il n'y a pas de génotype qui se distingue. Cette observation est tout à fait cohérente avec le modelé de sélection utilisé, à savoir la stabilité du phénotype. 

	\subsubsection{XP2: Temps d'homogénisation de la population}
	A partir de la première expérience, une question s'est posé. Quels sont les facteurs influençant le vitesse d'homogenisation de la population. C'est à dire à partir de quel itération la population devient homogène. 
	2 facteurs ont été testé. La taille de la population et le nombre de gène.
	{GRAPH}
	Au vu de ces résultats, il s'avère clairement que le nombre d’individu influence plus fortement le temps d' homogénisation. Ceci étant , l'experience reste logique. Plus le nombre d'individu est grand, et plus la dillution des gènes prendra du temps. 



	\subsection{Perrinou}


	\section {Conclusion}

		\begin{figure}[p]
	\label{figure3}
	\vspace*{-3cm}
	\caption[test]{}
	\includegraphics[scale=0.2, angle=90]{guituto.png}
	\end{figure}
	\end{document}
